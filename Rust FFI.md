## Rust FFI

As a relatively new programming language, Rust has very little existing codes and libraries compared to C/C++. When integrating Rust into the existing C/C++ projects, interoperations often become a necessity. In this summary, we'll dive deep into the world of FFI and examine the Rust FFIs in multiple aspects, including accessibility, practices, and performance.

## Linking and Binding

The first step towards the establishment of an FFI is making the interface visible across the FFI boundaries.

### Linking Rust codes into C

For linking Rust codes into C, Rustc provides compiler arguments `staticlib` and `cdylib`. When specified, Rustc will compile the Rust library to C-compatible static or dynamic library respectively, which is in `.a ` and `.lib`, or `.so` and `.dll` formats depending on the OS.

Functions in Rust don't follow the same conventions as C. To compile a function to be C-compatible, we need to turn off name mangling and mark it as `extern "C"` (or `extern`, which equals to `extern "C"` in the current version of Rust). For example, if we have a library for calculating Fibonacci sequence in Rust:

```rust
#[no_mangle]
pub extern "C" fn fib(n: i32) -> i32 {
    match n {
        1 => 1,
        2 => 2,
        _ => fib(n - 1) + fib(n - 2),
    }
}
```

On Windows, we can compile it to `fib.lib` to statically link it to C. Then declare the function using a header file:

```C
int fib(int n);
```

Now we can call function `fib` in C.

Note that `int` in C is not a platform-independent representation of `i32` in Rust, which we'll discuss in detail later.

### Linking C codes into Rust

On the opposite, using C code in Rust is also possible, where an `extern "C"` block importing C definitions into Rust can be adopted. Suppose we have a dynamic library written in C called `cdyn`, which is `cdyn.dll` on Windows:

```C
_declspec(dllexport) void hello_from_cdyn() {
    printf("hello rust from cdyn!\n");
}
```

We can then declare the function in Rust with the `extern "C"` block:

```rust
extern "C" {
    fn hello_from_cdyn();
}
```

Rustc will try to find the function and link the libraries accordingly. By default, Rustc will only look for libraries in several rust root directories. In this case, the name and location of `cdyn` should be supplied to Rustc by specifying the `rustc-link-lib` and `rustc-link-search` arguments.

`rustc-link-search` only takes full paths. A `build.rs` script is commonly used in Rust cargo projects:

```rust
use std::env;

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    println!("cargo:rustc-link-lib=dylib=cdyn");
    println!("cargo:rustc-link-search={}\\clib", manifest_dir);
}
```

Now Rustc will look for `cdyn.lib` in the `clib` folder in the project root and successfully link it.

## Binding Generation

To use a rust library in C, we need a header file containing all the C bindings to Rust FFIs, just like the case with C libraries. On the other way around, we need an `extern "C"` block containing all the Rust bindings to C APIs. This can be done manually, like what we did in the above examples. Though manual mapping can be tedious, this is where auto-generation of the bindings comes in.

### Generate C Bindings for Rust Libraries

`cbindgen` is a tool crate used to generate C bindings for Rust code, which can be easily integrated into the build script:

```rust
use std::env;
use cbindgen;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    cbindgen::generate(&crate_dir).unwrap().write_to_file("fib.h");
}
```

Build `fib.lib` then outputs a `fib.h`:

```c
#ifndef LIB_H
#define LIB_H

/* Generated with cbindgen:0.7.1 */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

int32_t fib(int32_t n);

#endif /* LIB_H */
```

`cbindgen` will come handy when dealing with complex types. We'll uncover this as we continue to explore the FFI between Rust and C.

### Generate Rust Bindings for C Libraries

Like `cbindgen`, there is `bindgen` crate used for binding generations in the opposite direction. If put C function `hello_from_cdyn` in a `src-c/wrapper.h`, we can assemble a build script like this:

```rust
use std::env;
use std::path::PathBuf;
use bindgen;

fn main() {
    let crate_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    bindgen::Builder::default()
        .header("src-c/wrapper.h")
        .generate()
        .expect("unable to generate bindings")
        .write_to_file(crate_dir.join("include").join("bindings.rs"))
        .expect("couldn't write bindings!");
}
```

When built, it generates Rust FFI bindings to the C library and outputs them to a `bindings.rs` file:

```rust
/* automatically generated by rust-bindgen */

extern "C" {
    pub fn hello_from_cc();
}
```

We can then automate the whole process by including the binding file using a macro:

```rust
include!(concat!(env!("CARGO_MANIFEST_DIR"), "\\include\\bindings.rs"));

fn main() {
    unsafe{
        hello_from_cdyn();
    }
}
```

## Interoperability

Now that we have a way to make the FFIs visible, we need to verify how compatible are the FFIs.

### Primitives

Both languages have similar integral and float primitives. Using `cbindgen`, we can obtain a list of C bindings for Rust types:

| Rust Type | C Type    |
| :-------- | --------- |
| bool      | bool      |
| char      | uint32_t  |
| i16       | int16_t   |
| u16       | uint16_t  |
| i32       | int32_t   |
| u32       | uint32_t  |
| i64       | int64_t   |
| u64       | uint64_t  |
| f32       | float     |
| f64       | double    |
| isize     | intptr_t  |
| usize     | uintptr_t |

Since C integral primitives are not platform-independent, C bindings for Rust integral primitives draw definitions from `stdbool.h` and `stdint.h`. 

Notice the correct representation of Rust `char` in C is an unsigned 32-bit integer, due to the UTF-32 encoding adopted by Rust. 

If we are to create Rust bindings for C primitives, we would have:

| C Type             | Rust Type                 |
| :----------------- | ------------------------- |
| char               | std::os::raw::c_char      |
| short              | std::os::raw::c_short     |
| unsigned short     | std::os::raw::c_ushort    |
| int                | std::os::raw::c_int       |
| unsigned int       | std::os::raw::c_uint      |
| long long          | std::os::raw::c_longlong  |
| unsigned long long | std::os::raw::c_ulonglong |
| void*              | std::os::raw::c_void      |

It is worth mentioning that Rust has a binding to C standard library - crate `libc`. It links to `std` by default. In a ``#![no_std]`` situation, crate `libc` should be used instead.

### Structs and Tuples

Rust doesn't have a guaranteed memory layout for its `struct`. A Rust `struct` most likely is going to have a different memory layout with a C `struct`. To make Rust `struct` FFI-safe, it needs to be marked with `#[repr(C)]`:

```rust
#[repr(C)]
pub struct Rectangle {
    length: i32,
    width: i32,
}
```

Rust's tuple-style `struct` can be interpreted by C as a `struct`:

```rust
#[repr(C)]
pub struct ITuple(i32,i32);
```

This gets translated into:

```C
typedef struct {
  int32_t _0;
  int32_t _1;
} ITuple;
```

Anonymous tuples like `(i32, i32)` aren't FFI-safe since there is no way to specify a layout for them. They need to be replaced with equivalent tuple-style `struct` when passed across the FFI boundaries.

In terms of OOP concepts, we can define methods for `sturct` in Rust. However, it is not possible to pass methods across an FFI boundary. For each relevant method, there has to be a wrapper function. Suppose we have a method for `Rectangle` that calculates its parameter, then we need a wrapper function that accepts a single pointer to call into the method:

```rust
impl Rectangle {
    fn parameter(&self) -> i32 {
        2 * (&self.length + &self.width)
    }
}

#[no_mangle] // a wrapper for Rectangle::parameter
pub extern "C" fn rect_parameter(rect: *const Rectangle) -> i32 {
    assert!(!rect.is_null());
    unsafe { (*rect).parameter() }
}
```

### Opaque Pointers

Because of the inherent nature of opaque pointers, they are a good representation of the concept of an object. In C, opaque pointers live in the form of dummy structs:

```C
typedef struct rust_database rust_database_t;

rust_database_t* rust_database_new(void);
void rust_database_free(rust_database_t *);
void rust_database_insert(rust_database_t *, const char*);

int main() {
    rust_database_t* database = rust_database_new();
    rust_database_insert(database, "117");
    rust_database_free(database);
}
```

In this simulation example, `rust_database_t` represents the type of object in Rust. Those functions are wrappers of its methods.

On the Rust side, we can represent an opaque pointer using similar empty types:

```rust
pub enum CDatabase {}

extern "C" {
    pub fn database_new() -> *mut CDatabase;
    pub fn database_free(arg: *mut CDatabase);
}
```

The same thing can be achieved using a `sturct` as well, though we need to put in an empty field to avoid the "no field" warning from Rustc:

```rust
#[repr(C)] pub struct CDatabase { _priv: [u8; 0] }
```

Do note that neither of these two representations is 100% accurate. The `enum` defines a type that cannot exist, whereas the latter defines a ZST(Zero-Sized Type). RFC 1861 proposes a way to declare an extern type using the `extern "c"` block, so opaque pointers will have more semantically accurate representations in the future.

### Ownership

As we've already seen, sometimes a `struct` is passed across FFI boundaries using raw pointers. To better demonstrate the process, suppose we have a constructor function of `Rectangle` in Rust:

```rust
#[no_mangle] // return Rust owned struct to C
pub extern "C" fn rect_new() -> *mut Rectangle {
    let rect = Box::new(Rectangle { length: 1, width: 1 });
    Box::into_raw(rect)
}
```

The whole process consists of allocating a `Rectangle` on the heap in a smart pointer and casting it to a raw pointer. The catch is that the allocated `rect` will be deleted pass the boundary of `rect_from_rust`. Therefore, `Box::into_raw` roughly equals to both a call to `std::mem::forget` and a cast to raw pointer.

Stack allocated struct needs to be passed across the boundary following the exact same procedure:

```rust
pub extern "C" fn rect_new_from_stack() -> *mut Rectangle {
    let rect = Rectangle { length: 1, width: 1 };
    Box::into_raw(Box::new(rect))
}
```

To pass a pointer from C to Rust, a null check is mandatory since the pointer from C can be null:

```rust
#[no_mangle] // process struct from C
pub extern "C" fn rect_area(p_rect: *mut Rectangle) -> i32 {
    assert!(!p_rect.is_null());
    let rect = unsafe { &(*p_rect) };
    rect.length * rect.width
}
```

It's also crucial that Rust doesn't take the ownership of `p_rect` here. If `Box::from_raw` is instead called:

```rust
pub extern "C" fn rect_area(p_rect: *mut Rectangle) -> i32 {
    assert!(!p_rect.is_null());
    let rect = unsafe { *Box::from_raw(p_rect) }; // takes onwership
    rect.length * rect.width
}
```

This results in deletion of `p_rect` after calling `rect_area`:

```C
int main() {
    Rectangle* rect = rect_new();
    printf("area of the rect: %d\n", rect_area(rect));
    // rect no longer valid
    printf("length and width: %d %d\n", rect->length, rect->width);
}
```

Deleting a rectangle after calculating its area doesn't really make sense. Though sometimes the ownership is supposed to be taken. For example, recycle the resource:

```rust
#[no_mangle] // free resource originally allocated in Rust
pub extern "C" fn rect_free(p_rect: *mut Rectangle) {
    unsafe {
        if p_rect.is_null() {
            return;
        }
        Box::from_raw(p_rect)
    };
}
```

It is critical that `rect_free` is provided alongside `rect_new` in the FFI. It may be intuitive to free the resource in C:

```C
int main() {
    Rectangle* rect = rect_from_rust();
    free(rect);
}
```

However, C is responsible for the timing of recycling the resource after taking its ownership, but not the execution. The allocators in both languages can be different. If the allocators are different, the assumptions deallocators make about the memory layout would be invalid. Thus this often results in memory corruption.

### Arrays

A C array technically consists of a pointer plus a size, which is actually how a Rust slice looks like.  So arrays are naturally interpreted as slices:

```Rust
#[no_mangle] // pass a C array to Rust
pub extern "C" fn sum_of_array(a: *const i32, len: size_t) -> i32 {
    assert!(!a.is_null());
    let numbers = unsafe { slice::from_raw_parts(a, len as usize) };
    numbers.iter().sum()
}
```

In this case, we're merely creating a reference to the array. There are times when we want to make a request from Rust to allocate resources in C, so we would want to take the ownership. A wrapper with proper destructors is commonly used for this particular scenario:

```rust
extern "C" {
    fn allocate(data_ptr: *mut *const i32, len: size_t);
    fn deallocate(data_ptr: *const i32);
}

struct IntArray {
    ptr: *const i32,
    len: usize,
}

impl std::ops::Deref for IntArray { // use IntArray like a i32 slice
    type Target = [i32];
    fn deref(&self) -> &[i32] {
        unsafe { slice::from_raw_parts(self.ptr, self.len) }
    }
}
impl Drop for IntArray { // direct deallocation back to C
    fn drop(&mut self) {
        unsafe { deallocate(self.ptr) };
    }
}

fn initiate(size: usize) -> IntArray {
    let mut ptr = ptr::null();
    unsafe {
        allocate(&mut ptr, 100 as size_t);
        assert!(!ptr.is_null());
    }
    IntArray { ptr, len: size }
}
```

This way, we're able to use the `IntArray` just like a rust slice, and we can let the ownership system take care of the resource management for us.

### Strings

In a way, strings are just character arrays. Though Rust `char` isn't compatible with C, `c_char` should be used when dealing with strings across the FFI boundaries. More importantly, C string doesn't always come with an explicit size. Instead, they terminate on null characters. This isn't the case for Rust `String`:

```rust
pub extern "C" fn rust_str_new() -> *const c_char {
    let mut s = String::from("Batman");
    s.as_ptr() as *const c_char
}
```

Returning `s` to C results in incorrect interpretation of the string in C due to the absence of a `\0` null terminator. To pass a Rust string to C, `CString` is provided:

```rust
#[no_mangle] // create a rust string and pass it to C
pub extern "C" fn rust_str_new() -> *const c_char {
    let mut s = String::from("Batman");
    let c_str = CString::new(s).unwrap();
    c_str.into_raw()
}

#[no_mangle] // free a rust string
pub extern "C" fn rust_str_free(s: *mut c_char) {
    unsafe {
        if s.is_null() {
            return;
        }
        CString::from_raw(s)
    };
}
```

`CString::new` takes a string, then append a `\0` null terminator to the end if there isn't. As mentioned before, deallocator `rust_str_free` should be paired with `rust_str_new`. 

`CString::into_raw` returns a `*mut c_char`, but we should return `*const c_char` whenever possible. `CString` works under the contract that there are no middle null terminators in the strings. When passing a string from Rust to C, it could get modified. Then when `rust_str_free` is called, `CString::from_raw` recalculates the length of the string, resulting in a partial deallocation/memory leak.

When dealing with a C string that is passed to Rust, `CStr` is up for the job:

```rust
#[no_mangle]
pub extern "C" fn cstr_length(s: *const c_char) -> u32 {
    assert!(!s.is_null());
    let c_str = unsafe { CStr::from_ptr(s) };
    let r_str = c_str.to_str().unwrap();
    r_str.chars().count() as u32
}
```

Under the hood, `CStr` is a `c_char` slice with C style interpretations. It provides a `to_str()` method to return a `&str` of its contents, thus enables operations on the string in Rust. A similar wrapper like `IntArray` can be adopted when it is necessary to take the ownership of the string from C.

### Enums

A plain `enum` is just a bunch of integers. Though a Rust `enum` can't have values that are not defined. Attempting to pass an undefined value results in an undefined behavior:

```rust
#[repr(C)]
#[derive(Debug)]
pub enum Number {
    Zero,
    One,
}

#[no_mangle]
pub extern "C" fn number_print(n: Number) {
    println!("{:?}", n);
}
```

```C
int main() {
    number_print(2); // leads to undefined behaviors
}
```

As for a complex Rust `enum`, the representation can get quite messy across the FFI boundaries. The closest approximation in C is an explicitly tagged union, which consists of C `enum`, `struct`, and `union`. Suppose we have a Rust `enum` that can be both an integer and a float type:

```rust
#[repr(C)]
pub enum Value {
    Integer(i32),
    FloatType(f64),
}
```

There are two important properties of the type `Value`. One is that it can hold multiple types. The other one is that it also retains the type safety. The former translates into a `union`, and the latter is represented through a type tag, namely an `enum`. Then we also need a `struct` to refer to the whole type:

```C
typedef enum {
    Integer,
    FloatType,
} Value_Tag;

typedef struct { // a tagged union
    Value_Tag tag;
    union {
        int32_t integer;
        double float_type;
    };
} Value;

// access through getters and setters to ensure type safety
int32_t getInteger(Value* v) {
    assert(v->tag == Integer);
    return v->integer;
}

void setInteger(Value* v, int32_t i) {
    v->tag = Integer;
    v->integer = i;
}
```

In most of the cases, passing a Rust `enum` across the FFI boundaries isn't the best choice. For example, the most frequently used `Result<T>` is a Rust `enum`. It can be a return value on success or an error code on failure. It wouldn't be wise to replicate the `Result<T>` on the other side of the FFI boundary. Instead, using the return value as error code and success result as an out parameter will be more ergonomic.

### Callbacks and Closures

Simple callbacks between C and Rust aren't anything special. A declaration of the interfaces on both sides would suffice. Suppose we have a long computation in C we'd like to call from Rust, where we also would like to get notified about the progress: 

```C
typedef void (*Progress)(float);

int32_t sum_from_one_to_n(int32_t n, Progress progress)
{
    int result = 0;
    for (int i = 1; i <= n; i++) {
        result += i;
        progress(i * 100.0 / n);
    }
    return result;
}
```

We leave a callback in the function parameter, so we can pass it from Rust:

```rust
type Progress = extern "C" fn(f32); // callback interface declaration

extern "C" {
    pub fn sum_from_one_to_n(n: i32, progress: Progress) -> i32;
}

fn main() {
    let ret = unsafe { sum_from_one_to_n(100, progress) };
}

extern "C" fn progress(percent: f32) { // the callback
    println!("Progress: {:.2}%", percent);
}
```

Dealing with closures is a bit more complicated. A Rust closure isn't just a function pointer. To pass a closure across the FFI boundary, we need to pass the whole closure as a `void*`, and pass a trampoline function for C to indirectly invoke the closure. Assume we have an accumulator closure to pass to a number generator in C:

```C
typedef void (*Progress)(int32_t);

void generate_numbers(int32_t iteration, Progress progress, void *data)
{
    for (int32_t i = 0; i < iteration; i++) {
        int32_t number = i * i;
        progress(data, number);
    }
}
```

The closure in Rust:

```rust
type Progress = extern "C" fn(*mut c_void, i32);

extern "C" {
    fn generate_numbers(interation: i32, data: *mut c_void, progress: Progress);
}

fn main() {
    let mut total = 0;
    unsafe {
        let mut accumulator = |n: i32| total += n;
        let (closure, trampoline) = unpack_closure(&mut accumulator);
        generate_numbers(20, closure, trampoline);
    }
}

unsafe fn unpack_closure<F>(closure: &mut F) -> (*mut c_void, Progress)
where F: FnMut(i32),
{
    extern "C" fn trampoline_func<FF>(data: *mut c_void, n: i32)
    where FF: FnMut(i32),
    {
        let fp: &mut FF = unsafe { &mut *(data as *mut FF) };
        (*fp)(n);
    }

    (closure as *mut F as *mut c_void, trampoline_func::<F>)
}
```

## Using C APIs in Rust

In previous sections, we mainly focus on the accessibility of the FFI between Rust and C. There are still a few things we need to keep in mind when calling C from Rust.

### Safe Interface

Rust deems everything from C as `unsafe`, thus every call of an `extern "C"` needs to be wrapped in an `unsafe` block:

```rust
extern "C" {
    pub fn c_sort(a: *mut i32, length: size_t);
}

fn main() {
    let mut a = [1, 3, 2, 6, 5, 4];
    unsafe { c_sort(a.as_mut_ptr(), a.len() as size_t); }
}
```

This type of `unsafe` calls can spiral out of control very fast. We should add a safe wrapper for the C APIs to minimize the unsafe boundaries:

```rust
extern "C" {
    pub fn c_sort(a: *mut i32, length: size_t);
}

fn sort(a: &mut [i32]) {
    unsafe { c_sort(a.as_mut_ptr(), a.len() as size_t); }
}

fn main() {
    let mut a = [1, 3, 2, 6, 5, 4];
    sort(&mut a);
}
```

Besides, by creating a safe binding, we can take advantage of Rust's memory safety guarantees. It is always a good idea to create a safe interface for the raw functions, no matter how trivial it might be. The same thing can be said for external global variables since access to them is considered `unsafe` as well :

```rust
extern "C" {
    static lib_version: i32;
}

fn check_lib_version() {
    unsafe { assert!(lib_version >= 100, true); }
}
```

### Exception Safety

Extra care needs to be taken when dealing with exceptions across the FFI boundaries. *The book* specifically points out that a `panic!` across an FFI boundary is undefined behavior.

We used `assert!` for pointer null checks in some examples of the previous sections. When such null checks fail, they will invoke `panic!`. Therefore, if a null check fails when called from C, it will be a `panic!` across the FFI boundary, which is undefined behavior. Rust provides `catch_unwind` for this particular scenario:

```rust
#[no_mangle]
pub extern "C" fn sum_of_array_ub(a: *const i32, len: size_t) -> i32 {
    assert!(!a.is_null()); // UB if null check fails across an FFI boundary
    let numbers = unsafe { slice::from_raw_parts(a, len as usize) };
    numbers.iter().sum()
}

#[no_mangle] // panic is caught so it can never go across the FFI boundary
pub extern "C" fn sum_of_array(a: *const i32, len: size_t) -> i32 {
    let result = catch_unwind(|| {
        assert!(!a.is_null());
    });
    match result {
        Ok(_) => {
            let numbers = unsafe { slice::from_raw_parts(a, len as usize) };
            numbers.iter().sum()
        }
        Err(_) => -1,
    }
}
```

However, the paradigm utilizing `catch_unwind` utterly turns an exception into an error code. In this particular case, `-1` isn't a safe representation of error, leaving the program to an incorrect state. As we mentioned in the discussion about enums, an error code pattern is more efficient:

```rust
#[no_mangle]
pub extern "C" fn sum_of_array(a: *const i32, len: size_t, out: *mut i32) -> i32 {
    if a.is_null() {
        return -1;
    }
    unsafe {
        let numbers = slice::from_raw_parts(a, len as usize);
        out.write(numbers.iter().sum());
    }
    0
}
```

`panic!` should be avoided once it reaches the FFI boundary. Unless we absolutely have to use `panic!`,  `catch_unwind` is rarely taken into consideration.

Strictly speaking, `catch_unwind` isn't a perfect solution for the `panic!` situation. It cannot catch a `panic!` that aborts the program. RFC 2797 has a proposal about specifying the undefined behavior when there is a `panic!` across the FFI boundary. For the time being, we should use old-fashioned error codes when we need to deal with exceptions.

## Performance in Rust FFI

Performance is one of the most critical aspects of a system programming language, which both C and Rust are. Function calls between Rust and C have identical performance to C function calls, thanks to Rust's zero-cost abstraction design. Rust also supports C-style structure memory layout, so there won't be any indirections when it comes to adapting primitives. However, there are still subtle differences that might cause overheads.

### Data Transformation

This kind of overhead occurs when we need to transform certain data types from Rust to C or C to Rust. Although the underlying memory layout is the same, the presentation might differ. String is the most noticeable one in this category.

We've already touched on this topic in the previous section about the interoperation on strings. C strings build on the concepts of null terminators, whereas Rust strings are vectors. When transforming strings between C and Rust, there will be inevitable checks and conversions. This may not cause major halts, but it's also not negligible.

### Exceptions

`catch_unwind` is mentioned as a way to block panics within the FFI boundaries. However, the use of  `catch_unwind` will cause significant drawbacks to code optimizations, even if there is no panic.

When dealing with panic becomes a necessity in the FFI environment, `catch_unwind` is the only choice. The optimization drawbacks also come along, which can be sub-optimal.

### Null Pointer Optimization

Nullable pointer optimization is a compile-time guarantee for a specific kind of `enum`.  When an `enum` has exactly two variants, one of which contains no data and the other contains a field of a non-nullable type, the empty variant is represented by putting a null value into the non-nullable field. This way, there is no need for two fields. The field of the non-nullable type is capable of representing the whole `enum`. `Option<T>` commonly adopts this kind of optimization since one of its field represents the said empty data. 

In the perspective of an FFI, an `enum` eligible for such optimizations effectively equals to a raw pointer. One such example is the function pointer:

```C
typedef void (*Progress)(float);
```

```Rust
type Progress = extern "C" fn(f32);
```

We directly translated a C function pointer to a rust function pointer in the callback example. If we get the Rust binding through generating, we'd instead have:

```rust
pub type Progress = Option<extern "C" fn(f32)>;
```

This isn't really necessary when passing a callback from Rust to C since Rust function pointers can't be null. Though it definitely comes handy when dealing with callbacks the other way around. The use of `Option` is less error prone compared to a C style null check.

## Rust and C++

As an appendix, we can take a look at the interoperability between Rust and C++. The story can be both simple and complicated.

Simple, in that Rust doesn't provide a C++ FFI, any interoperations need to be done through C. If the target C++ library has a C FFI, then Rust can treat it like a C library, vice versa.

Complicated, in that two layers of FFIs significantly increases the difficulty. If we were to use a C++ library in Rust, we need to write a C FFI for it, which is not actually that straightforward. Then we also need all the Rust bindings for the codes in C, which has another whole class of problems to solve.

That being said, FFI between Rust and C++ is actually an active topic in the Rust community. For example, crate `ritual` provides supports to generate bindings between Rust and C++. A few features like constant template parameters and template specializations are listed as unsupported since Rust currently doesn't provide the same kinds of functionality. Other than that, the process can be done with the right amount of automation.

## Summary

In this summary, many aspects of interoperability between Rust and C/C++ are examined, we can see:

- Rust supports compilations to C-compatible static and dynamic libraries. Linking them is just as easy as linking between C libraries.
- `cbindgen` and `bindgen` provide effective binding generations.
- All the types in both languages can be mapped into one another. Things can get complicated when dealing with ownerships, strings, and complex enums, but they are still relatively accessible.
- Creating a safe Rust interface for C APIs is always a good idea.
- Exceptions across the FFI boundaries are undefined behaviors. We can avoid this by catching exceptions preemptively.
- Performance in FFI doesn't have any overheads on the language level. There are a few catches in certain circumstances, but they are optimizable.
- Rust doesn't provide a C++ FFI, but the interoperations are viable with active community supports.

Overall, as a system programming language, Rust provides enough low-level manipulations to be well compatible with C. However, it's not always a straightforward translation. We need to be extra careful when dealing with FFIs.