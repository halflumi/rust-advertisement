Rust generics and C++ templates are powerful generalization tools designed for better abstraction. Despite having the same purposes, generics in Rust are far from being a simple rename of templates in C++.

In this summary, we'll take a glance at:

- Generic programming in C++ and Rust
- Differences between Rust generics and C++ templates

## Generic Programming

Generics is the idea to allow types to be a parameter to functions and classes. Generic programming enables the programmer to write a general algorithm that will work with all data types, which means better code reusability and less duplicate overloading. This is why a lot of modern programming languages support generic programming where C++ and Rust are no exceptions.

### The Initiative

C is quite a vanilla programming language in modern standards. Lack of supports for generics programming makes concept overlapping a real headache in C:

```C
float flarger(float a, float b) {
    if (a > b) {
        return a;
    }
    return b;
}

double flargerl(double a, double b) {
    if (a > b) {
        return a;
    }
    return b;
}
```

Technically speaking, we can use macros as a solution to this particular case, but that's a story too old to tell. Besides, using macros has many limitations that are off the topic of this summary. Let's focus on how C++ solves the problem.

### Generics in C++

To ease the pain of describing seemingly identical concepts, C++ introduces templates as an implementation of generics:

```c++
template<typename T>
T larger(T a, T b) {
    if (a > b) {
        return a;
    }
    return b;
}

int main() {
    larger(1.f, 2.f); // flarger
    larger(1., 2.); // flargerl
}
```

Templates are simply codes generated by the compiler on your behalf. ``larger`` it is literally expanded to `flarger` and `flargerl` after compilation if there are `float` and `double` instances of `larger`.

However, there are subtle implications for this short snippet to work, as we'll see in the Rust counterpart.

### Generics in Rust

Rust provides supports for generics in the form of generic functions and generic traits. If we write `larger` in Rust like C++:

```rust
fn larger<T>(a: T, b: T) -> T {
    if a > b {
        return a;
    }
    return b;
}
```

The compiler is going to complain about this:

```
error[E0369]: binary operation `>` cannot be applied to type `T`
```

Rustc says it doesn't know if type `T` implements trait `std::cmp::PartialOrd`. Rustc demands a guarantee `a > b` would work:

```rust
fn larger<T: std::cmp::PartialOrd>(a: T, b: T) -> T {
    if a > b {
        return a;
    }
    return b;
}

fn main() {
    larger(1., 1.); // flarger
    larger(1f64, 2f64); // flargerl
}
```

The requirement of trait bound in this case equals to that of the operator overload in C++ parlance. We don't need to specify that type `T` has an overload for `operator>` in C++ because the `larger` in C++ assumes that type `T` has such an overload. Compilation errors will arise if the said overload is absent, but the definition of the template is always considered valid.

As we can see, generics check at definition whereas templates check at instantiation. This is the ultimate cause of a multitude of differences between generics and templates, which we'll discuss in the next section of the summary.

## Rust Generics vs. C++ Templates

### Duck Typing

Because C++ templates don't check at definition, they are effectively duck typed, which equals to more flexibility. On paper, flexibility is a neutral word. It can be good or bad depending on how you look at it. Though in this case, it often leans towards to bad side.

In C++, a type doesn't have to meet all the requirements of a template to take advantage of the associated functions. For example:

```c++
struct Record {
	std::string name;
	Record(const std::string& name) : name(name) {}
	Record operator=(const Record&) = delete; // Delete the copy assignment operator
};

int main() {
	std::vector<Record> records;
	records.push_back(Record("diss"));
}
```

`Record` doesn't meet the requirements of `std::vector` since it doesn't support copy assignment operator. It's convenient that `Record` can still fit in, even working as intended. However, `std::vector<Record>` is considered to be a valid instantiation of `std::vector` only because there are no calls to the copy assignment operator of `Record`  in the code. If we were to go extreme:

```c++
int main() {
	std::vector<Record> records;
	records.push_back(Record("diss"));
	records.erase(records.begin());
}
```

This is where the notorious compilation errors of C++ templates comes in. Compiling the snippet(using GCC 6.3.0) results in a dozen rows of errors thrown with the report for a violation of deleted `operator=` at the very bottom.

Since C++ checks templates at instantiation, the violation can only be detected after the template is expanded. This leads to unfriendly compilation errors as the caller of `operator=` resides very deep in the  implementation. The compiler can only back-trace from the instantiation, hence the dreadful compilation errors.

The lack of boundaries at declaration pushes the specifications into the documentation, thus renders the incomprehensible errors inevitable because not everyone loves to read.

Rust generics are free of this kind of issue since they demand specifications upfront. The false function call will be caught if the requirement isn't met:

```rust
fn dup<T: Clone>(value: T) -> T {
    value.clone()
}

fn main() {
    dup(Record {});
}
```

This yields more conceivable compilation error:

```
error[E0277]: the trait bound `Record: std::clone::Clone` is not satisfied
  --> examples\check_at_definition.rs:6:9
   |
1  | fn dup<T: Clone>(value: T) -> T {
   |    ---    ----- required by this bound in `dup`
...
6  |     dup(Record {});
   |         ^^^^^^^^^ the trait `std::clone::Clone` is not implemented for `Record`
```

### Very Strict Rules

Rust generics are indeed more principled than C++ templates, but they may be proven to be rigid at times. Consider this:

```c++
struct A {
	std::string hello() { return "Hello from A"; }
};

struct B {
	std::string hello() { return "Hello from B"; }
};

template<typename T>
std::string call_hello(T instance) { return instance.hello(); }

int main() {
    call_hello(A());
    call_hello(B());
}
```

`call_hello` accepts `A` and `B`, which makes perfect sense since `A` and `B` both have method `hello()`. Though Rustc is unhappy about this:

```
error[E0599]: no method named `hello` found for reference `&T` in the current scope
  --> examples\method_duck_typing_failure.rs:12:53
   |
12 | fn call_hello<T>(instance: &T) -> String { instance.hello() }
   |                                                     ^ method not found in `&T`
```

This may look like the compiler is being overly suspicious. Yet this makes sense in the view of the compiler since it only cares about the definition. Even if the calls are legitimate, the compiler doesn't care.

To satisfy the compiler, the method needs to be abstracted to a trait:

```rust
trait Helloable {
    fn hello(&self) -> String;
}

impl Helloable for A {
    fn hello(&self) -> String { String::from("Hello from A") }
}

// impl Helloable for B ...

fn call_hello<T: Helloable>(instance: &T) -> String { instance.hello() }
```

Notice that the `impl` block needs to declare explicitly as `impl Helloable`, otherwise it won't count either.

This can be challenging to get used to under extreme circumstances:

```rust
struct Item1 { a: i32 }
struct Item2 { a: i32, b: i32 }

fn tell<T>(instance: &T) { println!("{}", instance.a); }
```

Rustc claims that type `&T` doesn't have field `a`. The snippet is only compiled if written as following:

```rust
trait HasA {
    fn get_a(&self) -> i32;
}

impl HasA for Item1 {
    fn get_a(&self) -> i32 { self.a }
}

// impl HasA for Item2 ...

fn tell<T: HasA>(instance: &T) { println!("{}", instance.get_a()); }
```

### Monomorphization

The monomorphization of generics and templates are quite similar, in that they both eventually generate multiple instances of the generalized concepts. The subtle difference is that the monomorphization of generics isn't entirely a process of copy-paste, which is the case of templates. For example, static variables defined in generics will only have one instance:

```rust
fn tempy<T>(dummy: T) {
    unsafe {
        static mut count: i32 = 0;
        println!("address: {}", (&count as *const _) as usize);
    }
}

fn main() {
    tempy(1);
    tempy(1.0);
}
```

The static variable in different instantiation of the generic function points to the same address:

```
address: 2953384
address: 2953384
```

Whereas the static variables defined in templates will have one instance for each instantiation of the template:

```c++
template<typename T>
void tempy(T dummy) {
    static int count = 0;
    std::cout << "address: " << &count << std::endl;
}

int main() {
    tempy(1);
    tempy(1.0);
}
```

The addresses are different:

```
address: 00DEC140
address: 00DEC144
```

### The Future

At the time of writing, comparing Rust to C++, *constant generics* (*non-type template parameters* in C++), *generic specialization* and *variadic generics* are still under heavy development. On the contrary, *concepts* are to be introduced in C++20, which is a lite version of *traits* in Rust. The gap between generics and templates will surely be closer in the foreseeable future.

## Conclusion

The story of generics vs. templates is ultimately about the differences between check at definition and check at instantiation. To serve the purpose of generic programming, they both have advantages and disadvantages.

Team Rust:

- Explicit constraints on generics that offer clear boundaries and informative compilation errors
- Trait bound rules that can be overly restrictive at times
- Current lack of some generic features making it less powerful compared to templates in C++

Team C++:

- A more competent metaprogramming system
- Duck typed templates that are very flexible
- Lack of constraints that can lead to misuses of templates
- Lengthy template compilation errors that are often incomprehensible